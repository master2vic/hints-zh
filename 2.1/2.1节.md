# 2.原理

本节中的思想不仅仅是提示，他们也是系统设计的基本工具。

## 2.1 抽象-- *有规范*

抽象的目的不是要含糊其辞，而是为了创造一个新的语义层次，在这个层次上，人们可以做到绝对精确。--**Edsger Dijkstra**

没有一个规范，一个系统若没有出错，这只能是令人惊讶的。--**Gary McGraw**

如果你不是在写程序，不要使用编程语言。  --**Leslie Lamport**

最困难的部分…是得到一个完整和一致的规范，而大部分的[工作]是调试规范。 --**Fred Brooks**

[体系结构]是计算机的结构。机器语言程序员必须理解这种结构，才能为该计算机编写正确的（与时间无关的）程序。  --**Amdahl, Blaauw, and Brooks**

在语言、概念或意义上对精确性的追求是徒劳无功的。  --**Karl Popper**

在计算机中，抽象是最重要的概念。这是一种是事情足够简单的方法，你有限的大脑能够使机器做你想做的事情，即使它所做的事情的细节太复杂了以致于你无法追踪：许多、许多步骤，许多、许多位的数据。这个概念是让计算机系统有一种规范来告诉它的用户。

   --是什么：他们需要知道的使用系统的一切，

   --而不是怎么样：关于它在内部如何工作的任何信息，我们将称之为代码（**code**）,因为“实现”(**implementation**)这个单词太长了。

规范通常比代码更小更清晰，并且它将客户机与代码的细节分离开来，这样，==客户机的生活==就能更简单，并且代码能够在不影响客户机的情况下更改。抽象，如果简单明了就是比较好的，如果你有限的大脑能够有效地使用它就是足够好的。

一个系统的状态是它所有变量的值。规范使用了数学中的基本概念（通常是关系及其它们得到特殊情况：集合、序列、元组、函数和图）来描述客户机的状态视图。这是抽象的状态。例如，文件系统抽象将文件描述成一对：大小加上许多字节的序列(数组或者列表)（序列是一种将0~size-1映射到字节的函数）。在代码内部有数据块、索引块、缓存、存储分配器、崩溃恢复等等，但是这些都没有出现在规范中。规范将客户机中代码的复杂性隐藏起来。几乎所有的规范都要简单得多，所以==客户机的生活==要简单得多。如果不是，你可能做错了什么。

规范也描述了读取和改变状态的操作，文件具有读取、写入和设置长度的操作。状态和操作定义状态机或过度系统。动作**a**只是一组可能的从前状态**s**到后状态**s'**的过渡或步骤，==所以它也可以被描述为一种关系，在状态对**(s，s')**上的谓词。当一个从**s**到**s'**的步骤是操作的一个步骤时，这个谓词是真的。==有许多符号（通常称为编程语言）可以方便、清晰地记录这些关系，但**一阶逻辑**是所有这些关系的基础。例如：x:=y是谓词𝑥′=𝑦的缩写并且==(∀ 𝑣 except  𝑥 | 𝑣′ = 𝑣)==；现在x的值为y的值并且其他变量保持不变。如果一个操作是不确定的，则可能有多个可能的下一个状态；如果它被阻塞，则可能没有。系统的行为（也称为历史或跟踪）只是系统可以采取的一系列步骤。

为什么在规范中使用数学？为了清晰和精确。你也可以用英语散文写下状态和操作。这可能是一个很好的开始，但令人惊讶的是很难使英文规范完整和正确。作为注释的散文可以帮助开发人员对系统的直觉，但是当您尝试将其转换为数学时，通常你会发现忽略了许多细节，甚至没有正确的词汇表来清楚、简洁地表达它们。

在代码中描述操作最常用的方式是作为顺序命令程序中的语句；因为语句是动作，所以它的含义是一种关系：

a,b是操作𝑎 ∘ 𝑏的组成部分。在确定的程序中，恰好有一个处在a之后的下一状态a(s)，==这就是函数组成，一个接一个的语句𝑠′ = 𝑏(𝑎(𝑠)).更一般地，如果存在某种中间状态 𝑠𝑖 使得a可以从s产生，并且b可以变成s'，那么𝑎 ∘ 𝑏 与状态s到状态s‘有关： ∃𝑠𝑖  𝑎(𝑠,𝑠𝑖)·𝑏(𝑠𝑖,𝑠′).==

对于if x then a else b,解释为(x·a)||(~x·b)

==对于f(x),解释为如果𝑦是𝑓的形式参数，那么(y=x)·f==

For var x do a it’s the somewhat surprising ∃𝑥 suchthat 𝑎. （不会翻译）

并发程序也有一些关于程序计数器的复杂问题。

通常将这种规范称为系统的“意义”，或者（特别是对于编程语言）称为“语义”，因为它只依赖于数学。操作对规范和状态同样重要，尽管有时状态的选择会使操作变得非常明显，以至于看起来并不重要。但通常这些操作应该遵循抽象有益的部分。一个简单的例子是键值存储，这些操作是：

​	𝑟𝑒𝑎𝑑(𝑘𝑒𝑦):得到键对应的值

​	𝑤𝑟𝑖𝑡𝑒(𝑘𝑒𝑦,𝑣𝑎𝑙𝑢𝑒) ：如果不是只读的

​	𝑒𝑛𝑢𝑚𝑒𝑟𝑎𝑡𝑒(𝑘𝑒𝑦1,𝑘𝑒𝑦2) ：如果键是有序的，返回键的集合

​	𝑠𝑒𝑎𝑟𝑐ℎ(𝑞𝑢𝑒𝑟𝑦) ：如果有方法搜索具有某些属性的键或值，返回键

规范可以是非常局部的，只描述一些行为；然后它通常被称为属性。例如，它可能只指定“没有==segfault==”，即任何不是segfault的步骤都可以。类型安全和内存安全是属性。除了局部的，一个规范可能是不确定的：一组结果中的任何一个都是可以接受的；例如，一个定时规范：“小于200毫秒”。而且通常细节应该保持开放：最终的一致性只是说在下一次同步（如果有）结束时更新肯定是可见的；否则它不会指定何时更新是可见的。语言通常指定不确定性，例如，当可以按任何顺序计算可能有副作用的函数参数时；当然，代码是确定性的。

代码应该满足(符合)规范。这意味着代码的每个可见行为也是规范的可见行为。“可见”是很重要的；通常代码的内部状态是不可见的，规范也一样。部分规范通常具有少数可见的状态。==限制了可能的行为集合例如不干涉（结果不依赖于秘密的值）的“超属性”超出范围。==

找到良好的抽象是设计系统最重要的部分。语言提供了一些内置的属性：字符串，数组，字典，函数。这些是有用的，但是它们没有你构建的平台中的抽象（如文件、网络、关系数据、向量和矩阵等）重要。而这些反过来又不如特定于应用程序的抽象重要。

哪个排在第一位，规范或代码？理论上规范排在第一位，因为它反映了你想要做什么；这称作自顶向下设计，代码是规范的一种改进。实践中，他们一起发展，因为在看见规范怎样影响代码和系统的用户之前，你无法说明规范应该是什么。规范的第一个想法通常与代码联系得太紧密了，并且通常提供的内容比客户需要的更多或更少。因此，获得规范的过程不同于拥有规范后对系统的思考。

### 2.1.1 安全与活跃度

任何只说明哪些可见行为是正常的规范都是由两部分组成的：

①安全规范，上面写着什么坏事都不会发生。如果代码违反了安全规范，那么坏事将在有限的步骤中发生。什么都不做的代码满足所有的安全规范。

②活跃度规范，上面写着一些好的事情最终会发生，通常是公平的：安全允许的每一个行为最终都会发生。没有有限的行为可以违背活跃度，因为好的事情可能会在以后发生。

对于非交互式顺序程序（接受单个输入并产生单个结果的程序），安全和活跃度被称为局部的正确和终止。通常安全是最重要的，因为“最终”不是很有用；你关心的是在两秒钟内得到结果，这是一个安全属性（在两秒钟后被违反）。但活跃度证明通常通过计算步骤、循环迭代、函数调用或其他方式工作，因此包含一个时间限制的证明。

### 2.1.2 操作

上面的描述完全是根据状态变化写的。通常，更容易将可视行为描述为客户端可以调用的操作序列和系统返回的结果。例如，先进先出缓冲区的规范有put（x）和get（）返回y的操作（参数和结果值是操作的一部分），其内部状态是get已放置但尚未检索的项序列。==对于每个转换（可见的或内部的）具有操作的状态机也称为标记的转换系统。==

将可见行为描述为一系列操作似乎与将它描述为一系列状态不同。操作（函数调用）在编程语言中是自然的，对状态（寄存器和内存）的更改在硬件中是自然的。但是这两个视图是等价的；协调它们的是调用序列的概念，一个对应于调用操作并获得结果的状态更改序列。有许多可能的调用序列：

1.执行机器指令；机械装置藏于CPU硬件中。

2.将一些参数存入特定的寄存器中，执行一条将PC保存到寄存器中的分支和链接指令，并从特定的寄存器获取结果。

3.将一些参数压入栈中，执行将PC压入栈中的调用指令，并从栈顶部获取结果。

4.将参数封装到数据包中，将其发送到RPC服务器，并等待结果数据包。

通常，操作系统会在这些PC存储序列中的一个上进行标准化，因此你可以忘记它，并用操作的方式描述可见的行为。
